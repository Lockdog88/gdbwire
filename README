Welcome to gdbwire.

Dependencies
------------

You must have the following packages installed.
  sh
  autoconf
  automake
  aclocal
  autoheader
  flex
  bison
  gcc/g++

Preparing the configure
-----------------------

Run ./autogen.sh in the current working directory to generate the configure
script.

Running configure, make and make install
----------------------------------------

You can run ./configure from within the source tree, however I usually run
configure from outside the source tree like so,
  mkdir ../build
  cd ../build
  YFLAGS="-Wno-deprecated" CFLAGS="-g -Wall -Werror" CXXFLAGS="-g -Wall -Werror" ../gdbwire/configure --prefix=$PWD/../prefix --enable-tests --enable-examples
  make -srj4
  make install

The make install rule is optional. You can simply run make and the executables
will be in there respective build directories. 

If you like to have a silent build, and the libtool link lines are
bothering you, you can set this environment variable to suppress
libtools printing of the link line,
  LIBTOOLFLAGS=--silent

Running the test suite
---------------------

If you want to run the test suite you have to tell the build system
to build it. This is done by passing --enable-tests on the configure line.

After you have built the test suite, you can run all the unit tests with
the command,
  ./test_suite

Ensure that you introduce no memory leaks or memory errors in the test suite.
You can do this with the command,
    LD_LIBRARY_PATH=$PWD/.libs/ valgrind  --leak-check=full --tool=memcheck ./.libs/test_suite
in the directory where the test_suite executable is created. You should
expect to see valgrind output something like,
 
    HEAP SUMMARY:
        in use at exit: 0 bytes in 0 blocks
        total heap usage: X allocs, X frees, Y bytes allocated

        All heap blocks were freed -- no leaks are possible

        For counts of detected and suppressed errors, rerun with: -v
        ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)

An overview of the source code
------------------------------

src/                    # All source code is in here
src/progs               # All programs go here
src/progs/test_suite    # The unit test executable
src/progs/examples      # Example programs using the gdbwire interfaces
src/lib                 # All libraries go here
src/lib/containers      # All containers go here (string, list, etc)
src/lib/logging         # A logging library based on clog
src/lib/gdbmi           # The gdbmi interface

Developer Conventions
---------------------

Proper Error handling is an important part of gdbwire. This library
is intended to be used by other applications and it is important to provide
appropriate error messages to the end users when necessary.

Result codes have been chosen as the primary means of returning status
from a function. The result codes are an enumeration called gdbwire_result,
which is defined in the file gdbwire_result.h. GDBWIRE_OK is a successful
result status and all others indicate a particular error condition.

Not all functions need to return a result code. A function may return
void if it can not fail. A function can return a NULL pointer when it makes
sense to do so. Common sense should be applied.

As a rule of thumb, error conditions should be handled if possible.
Otherwise they should bubble up. This should repeat at each level until
the gdbwire user receives the proper error result.

It is encouraged that all function interfaces are documented and that
the preconditions of the functions are clearly stated. The function body
is encouraged to assert those preconditions to catch errors as soon as
possible. Some macros have been added to help with this matter.
GDBWIRE_ASSERT and GDBWIRE_ASSERT_ERRNO in gdbwire_assert.h are intended
to help the developer both assert, log and return an appropriate
error status on assertion failure. GDBWIRE_ASSERT_GOTO has been added
to avoid duplicating error handling code in a function. The common
error handling code can be written in a label that similar error
states can jump to. Other macros may be added to help facilitate
automatic error checking, logging and error propagation.

Finally, the gdbwire users will most likely hit issues in the field
that the source code in gdbwire does not expect. In these situations
it is appropriate to use the gdbwire_logger interface to log all
information that might be useful to help reproduce or fix an issue
that the user has encountered. The least amount of useful information
would be optimal.
